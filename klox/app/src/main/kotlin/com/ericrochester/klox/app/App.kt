/*
 * This Kotlin source file was generated by the Gradle 'init' task.
 */
package com.ericrochester.klox.app

import com.ericrochester.klox.Interpreter
import com.ericrochester.klox.Parser
import com.ericrochester.klox.Resolver
import com.ericrochester.klox.RuntimeError
import com.ericrochester.klox.Scanner
import com.ericrochester.klox.Token
import com.ericrochester.klox.TokenType
import java.io.BufferedReader
import java.io.InputStreamReader
import java.nio.charset.StandardCharsets
import java.nio.file.Files
import java.nio.file.Paths

val interpreter: Interpreter = Interpreter()

var hadError = false
var hadRuntimeError = false

// TODO: We have methods on instances, but there is no way to define “static”
// methods that can be called directly on the class object itself. Add support
// for them. Use a class keyword preceding the method to indicate a static
// method that hangs off the class object.
// 
// class Math {
//   class square(n) {
//     return n * n;
//   }
// }
// 
// print Math.square(3); // Prints "9".
//
// You can solve this however you like, but the “metaclasses” used by Smalltalk
// and Ruby are a particularly elegant approach. Hint: Make LoxClass extend
// LoxInstance and go from there.

// TODO: Most modern languages support “getters” and “setters”—members on a
// class that look like field reads and writes but that actually execute user-
// defined code. Extend Lox to support getter methods. These are declared
// without a parameter list. The body of the getter is executed when a property
// with that name is accessed.
// 
// class Circle {
//   init(radius) {
//     this.radius = radius;
//   }
// 
//   area {
//     return 3.141592653 * this.radius * this.radius;
//   }
// }
// 
// var circle = Circle(4);
// print circle.area; // Prints roughly "50.2655".

fun main(args: Array<String>) {
  if (args.size > 1) {
    println("Usage: klox [script]")
    System.exit(64)
  } else if (args.size == 1) {
    runFile(args[0])
  } else {
    runPrompt()
  }
}

private fun runFile(path: String) {
  val bytes = Files.readAllBytes(Paths.get(path))
  val source = String(bytes, StandardCharsets.UTF_8)
  run(source)
  if (hadError) System.exit(65)
  if (hadRuntimeError) System.exit(70)
}

private fun runPrompt() {
  val reader = BufferedReader(InputStreamReader(System.`in`))

  while (true) {
    print("> ")
    val line = reader.readLine()
    if (line == null) break
    run(line)
    hadError = false
  }
}

private fun run(source: String) {
  val tokens = Scanner(source).scanTokens()
  val statements = Parser(tokens).parse()

  if (hadError) return

  Resolver(interpreter).resolve(statements.filterNotNull())

  // Stop if there was a resolution error.
  if (hadError) return

  interpreter.interpret(statements)
}

fun error(line: Int, message: String) {
  report(line, "", message)
}

fun error(token: Token, message: String) {
  if (token.type == TokenType.EOF) {
    report(token.line, " at end", message)
  } else {
    report(token.line, " at '${token.lexeme}'", message)
  }
}

fun report(line: Int, where: String, message: String) {
  System.err.println("[line $line] Error$where: $message")
  hadError = true
}

fun runtimeError(error: RuntimeError) {
  System.err.println("${error.message} [line ${error.token.line}]")
  hadRuntimeError = true
}
